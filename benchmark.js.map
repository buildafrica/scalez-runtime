{"version":3,"file":"benchmark.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAPA;AAAA;AAQA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AALA;AAAA;AAOA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAUA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAMA;AAEA;AACA;AAGA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;;;;;;AChvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7BA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AEhDA;AACA;AACA;AACA;AACA","sources":["webpack://scratch-vm/webpack/universalModuleDefinition","webpack://scratch-vm/./src/playground/benchmark.js","webpack://scratch-vm/webpack/bootstrap","webpack://scratch-vm/webpack/runtime/amd options","webpack://scratch-vm/webpack/runtime/chunk loaded","webpack://scratch-vm/webpack/runtime/compat get default export","webpack://scratch-vm/webpack/runtime/define property getters","webpack://scratch-vm/webpack/runtime/global","webpack://scratch-vm/webpack/runtime/hasOwnProperty shorthand","webpack://scratch-vm/webpack/runtime/make namespace object","webpack://scratch-vm/webpack/runtime/node module decorator","webpack://scratch-vm/webpack/runtime/publicPath","webpack://scratch-vm/webpack/runtime/jsonp chunk loading","webpack://scratch-vm/webpack/before-startup","webpack://scratch-vm/webpack/startup","webpack://scratch-vm/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"scratch-vm\"] = factory();\n\telse\n\t\troot[\"scratch-vm\"] = factory();\n})(self, () => {\nreturn ","// Track loading time with timestamps and if possible the performance api.\nif (window.performance) {\n    // Mark with the performance API when benchmark.js and its dependecies start\n    // evaluation. This can tell us once measured how long the code spends time\n    // turning into execution code for the first time. Skipping evaluation of\n    // some of the code can help us make it faster.\n    performance.mark('Scratch.EvalStart');\n}\n\nclass LoadingMiddleware {\n    constructor () {\n        this.middleware = [];\n        this.host = null;\n        this.original = null;\n    }\n\n    install (host, original) {\n        this.host = host;\n        this.original = original;\n        const {middleware} = this;\n        return function (...args) {\n            let i = 0;\n            const next = function (_args) {\n                if (i >= middleware.length) {\n                    return original.call(host, ..._args);\n                }\n                return middleware[i++](_args, next);\n            };\n            return next(args);\n        };\n    }\n\n    push (middleware) {\n        this.middleware.push(middleware);\n    }\n}\n\nconst importLoadCostume = require('../import/load-costume');\nconst costumeMiddleware = new LoadingMiddleware();\nimportLoadCostume.loadCostume = costumeMiddleware.install(importLoadCostume, importLoadCostume.loadCostume);\n\nconst importLoadSound = require('../import/load-sound');\nconst soundMiddleware = new LoadingMiddleware();\nimportLoadSound.loadSound = soundMiddleware.install(importLoadSound, importLoadSound.loadSound);\n\nconst ScratchStorage = require('scratch-storage');\nconst VirtualMachine = require('..');\nconst Runtime = require('../engine/runtime');\n\nconst ScratchRender = require('scratch-render');\nconst AudioEngine = require('scratch-audio');\nconst ScratchSVGRenderer = require('scratch-svg-renderer');\n\nconst Scratch = window.Scratch = window.Scratch || {};\n\nconst ASSET_SERVER = 'https://cdn.assets.scratch.mit.edu/';\nconst PROJECT_SERVER = 'https://cdn.projects.scratch.mit.edu/';\n\nconst SLOW = .1;\n\nconst projectInput = document.querySelector('input');\n\ndocument.querySelector('.run')\n    .addEventListener('click', () => {\n        window.location.hash = projectInput.value;\n        location.reload();\n    }, false);\n\nconst setShareLink = function (json) {\n    document.querySelector('.share')\n        .href = `#view/${btoa(JSON.stringify(json))}`;\n    document.querySelectorAll('.share')[1]\n        .href = `suite.html`;\n};\n\nconst loadProject = function () {\n    let id = location.hash.substring(1).split(',')[0];\n    if (id.length < 1 || !isFinite(id)) {\n        id = projectInput.value;\n    }\n    Scratch.vm.downloadProjectId(id);\n    return id;\n};\n\n/**\n * @param {Asset} asset - calculate a URL for this asset.\n * @returns {string} a URL to download a project file.\n */\nconst getProjectUrl = function (asset) {\n    const assetIdParts = asset.assetId.split('.');\n    const assetUrlParts = [PROJECT_SERVER, 'internalapi/project/', assetIdParts[0], '/get/'];\n    if (assetIdParts[1]) {\n        assetUrlParts.push(assetIdParts[1]);\n    }\n    return assetUrlParts.join('');\n};\n\n/**\n * @param {Asset} asset - calculate a URL for this asset.\n * @returns {string} a URL to download a project asset (PNG, WAV, etc.)\n */\nconst getAssetUrl = function (asset) {\n    const assetUrlParts = [\n        ASSET_SERVER,\n        'internalapi/asset/',\n        asset.assetId,\n        '.',\n        asset.dataFormat,\n        '/get/'\n    ];\n    return assetUrlParts.join('');\n};\n\nclass LoadingProgress {\n    constructor (callback) {\n        this.dataLoaded = 0;\n        this.contentTotal = 0;\n        this.contentComplete = 0;\n        this.hydrateTotal = 0;\n        this.hydrateComplete = 0;\n        this.memoryCurrent = 0;\n        this.memoryPeak = 0;\n        this.callback = callback;\n    }\n\n    sampleMemory () {\n        if (window.performance && window.performance.memory) {\n            this.memoryCurrent = window.performance.memory.usedJSHeapSize;\n            this.memoryPeak = Math.max(this.memoryCurrent, this.memoryPeak);\n        }\n    }\n\n    attachHydrateMiddleware (middleware) {\n        const _this = this;\n        middleware.push((args, next) => {\n            _this.hydrateTotal += 1;\n            _this.sampleMemory();\n            _this.callback(_this);\n            return Promise.resolve(next(args))\n                .then(value => {\n                    _this.hydrateComplete += 1;\n                    _this.sampleMemory();\n                    _this.callback(_this);\n                    return value;\n                });\n        });\n    }\n\n    on (storage, vm) {\n        const _this = this;\n\n        this.attachHydrateMiddleware(costumeMiddleware);\n        this.attachHydrateMiddleware(soundMiddleware);\n\n        const _load = storage.webHelper.load;\n        storage.webHelper.load = function (...args) {\n            if (_this.dataLoaded === 0 && window.performance) {\n                // Mark in browser inspectors how long it takes to load the\n                // projects initial data file.\n                performance.mark('Scratch.LoadDataStart');\n            }\n\n            const result = _load.call(this, ...args);\n\n            if (_this.dataLoaded) {\n                if (_this.contentTotal === 0 && window.performance) {\n                    performance.mark('Scratch.DownloadStart');\n                }\n\n                _this.contentTotal += 1;\n            }\n            _this.sampleMemory();\n            _this.callback(_this);\n\n            result.then(() => {\n                if (_this.dataLoaded === 0) {\n                    if (window.performance) {\n                        // How long did loading the data file take?\n                        performance.mark('Scratch.LoadDataEnd');\n                        performance.measure('Scratch.LoadData', 'Scratch.LoadDataStart', 'Scratch.LoadDataEnd');\n                    }\n\n                    _this.dataLoaded = 1;\n\n                    window.ScratchVMLoadDataEnd = Date.now();\n                } else {\n                    _this.contentComplete += 1;\n                }\n\n                if (_this.contentComplete && _this.contentComplete === _this.contentTotal) {\n                    if (window.performance) {\n                        // How long did it take to download the html, js, and\n                        // all the project assets?\n                        performance.mark('Scratch.DownloadEnd');\n                        performance.measure('Scratch.Download', 'Scratch.DownloadStart', 'Scratch.DownloadEnd');\n                    }\n\n                    window.ScratchVMDownloadEnd = Date.now();\n                }\n\n                _this.sampleMemory();\n                _this.callback(_this);\n            });\n            return result;\n        };\n        vm.runtime.on(Runtime.PROJECT_LOADED, () => {\n            // Currently LoadingProgress tracks when the data has been loaded\n            // and not when the data has been decoded. It may be difficult to\n            // track that but it isn't hard to track when its all been decoded.\n            if (window.performance) {\n                // How long did it take to load and hydrate the html, js, and\n                // all the project assets?\n                performance.mark('Scratch.LoadEnd');\n                performance.measure('Scratch.Load', 'Scratch.LoadStart', 'Scratch.LoadEnd');\n            }\n\n            window.ScratchVMLoadEnd = Date.now();\n\n            // With this event lets update LoadingProgress a final time so its\n            // displayed loading time is accurate.\n            _this.sampleMemory();\n            _this.callback(_this);\n        });\n    }\n}\n\nclass StatTable {\n    constructor ({table, keys, viewOf, isSlow}) {\n        this.table = table;\n        if (keys) {\n            this.keys = keys;\n        }\n        if (viewOf) {\n            this.viewOf = viewOf;\n        }\n        if (isSlow) {\n            this.isSlow = isSlow;\n        }\n    }\n\n    render () {\n        const table = this.table;\n        Array.from(table.children)\n            .forEach(node => table.removeChild(node));\n        const keys = this.keys();\n        for (const key of keys) {\n            this.viewOf(key).render({\n                table,\n                isSlow: frame => this.isSlow(key, frame)\n            });\n        }\n    }\n}\n\nclass StatView {\n    constructor (name) {\n        this.name = name;\n        this.executions = 0;\n        this.selfTime = 0;\n        this.totalTime = 0;\n    }\n\n    update (selfTime, totalTime, count) {\n        this.executions += count;\n        this.selfTime += selfTime;\n        this.totalTime += totalTime;\n    }\n\n    render ({table, isSlow}) {\n        const row = document.createElement('tr');\n        let cell = document.createElement('td');\n        cell.innerText = this.name;\n        row.appendChild(cell);\n\n        if (isSlow(this)) {\n            row.setAttribute('class', 'slow');\n        }\n\n        cell = document.createElement('td');\n        cell.style.textAlign = 'right';\n        cell.innerText = '---';\n        // Truncate selfTime. Value past the microsecond are floating point\n        // noise.\n        this.selfTime = Math.floor(this.selfTime * 1000) / 1000;\n        if (this.selfTime > 0) {\n            cell.innerText = (this.selfTime / 1000).toFixed(3);\n        }\n        row.appendChild(cell);\n\n        cell = document.createElement('td');\n        cell.style.textAlign = 'right';\n        cell.innerText = '---';\n        // Truncate totalTime. Value past the microsecond are floating point\n        // noise.\n        this.totalTime = Math.floor(this.totalTime * 1000) / 1000;\n        if (this.totalTime > 0) {\n            cell.innerText = (this.totalTime / 1000).toFixed(3);\n        }\n        row.appendChild(cell);\n\n        cell = document.createElement('td');\n        cell.style.textAlign = 'right';\n        cell.innerText = this.executions;\n        row.appendChild(cell);\n\n        table.appendChild(row);\n    }\n}\n\nclass RunningStats {\n    constructor (profiler) {\n        this.stepThreadsInnerId = profiler.idByName('Sequencer.stepThreads#inner');\n        this.blockFunctionId = profiler.idByName('blockFunction');\n        this.stpeThreadsId = profiler.idByName('Sequencer.stepThreads');\n\n        this.recordedTime = 0;\n        this.executed = {\n            steps: 0,\n            blocks: 0\n        };\n    }\n\n    update (id, arg, selfTime, totalTime, count) {\n        if (id === this.stpeThreadsId) {\n            this.recordedTime += totalTime;\n        } else if (id === this.stepThreadsInnerId) {\n            this.executed.steps += count;\n        } else if (id === this.blockFunctionId) {\n            this.executed.blocks += count;\n        }\n    }\n}\n\nconst WORK_TIME = 0.75;\n\nclass RunningStatsView {\n    constructor ({runningStats, maxRecordedTime, dom}) {\n        this.recordedTimeDom =\n            dom.getElementsByClassName('profile-count-amount-recorded')[0];\n        this.stepsLoopedDom =\n            dom.getElementsByClassName('profile-count-steps-looped')[0];\n        this.blocksExecutedDom =\n            dom.getElementsByClassName('profile-count-blocks-executed')[0];\n\n        this.maxRecordedTime = maxRecordedTime;\n        this.maxWorkedTime = maxRecordedTime * WORK_TIME;\n        this.runningStats = runningStats;\n    }\n\n    render () {\n        const {\n            runningStats,\n            recordedTimeDom,\n            stepsLoopedDom,\n            blocksExecutedDom\n        } = this;\n        const {executed} = runningStats;\n        const fractionWorked = runningStats.recordedTime / this.maxWorkedTime;\n        recordedTimeDom.innerText = `${(fractionWorked * 100).toFixed(1)} %`;\n        stepsLoopedDom.innerText = executed.steps;\n        blocksExecutedDom.innerText = executed.blocks;\n    }\n}\n\nclass Frames {\n    constructor (profiler) {\n        this.profiler = profiler;\n\n        this.frames = [];\n    }\n\n    update (id, arg, selfTime, totalTime, count) {\n        if (id < 0) return;\n        if (!this.frames[id]) {\n            this.frames[id] = new StatView(this.profiler.nameById(id));\n        }\n        this.frames[id].update(selfTime, totalTime, count);\n    }\n}\n\nconst frameOrder = [\n    'blockFunction',\n    'execute',\n    'Sequencer.stepThread',\n    'Sequencer.stepThreads#inner',\n    'Sequencer.stepThreads',\n    'RenderWebGL.draw',\n    'Runtime._step'\n];\n\nclass FramesTable extends StatTable {\n    constructor (options) {\n        super(options);\n\n        this.profiler = options.profiler;\n        this.frames = options.frames;\n    }\n\n    keys () {\n        const keys = Object.keys(this.frames.frames)\n            .map(id => this.profiler.nameById(Number(id)));\n        keys.sort((a, b) => frameOrder.indexOf(a) - frameOrder.indexOf(b));\n        return keys;\n    }\n\n    viewOf (key) {\n        return this.frames.frames[this.profiler.idByName(key)];\n    }\n\n    isSlow () {\n        return false;\n    }\n}\n\nclass Opcodes {\n    constructor (profiler) {\n        this.blockFunctionId = profiler.idByName('blockFunction');\n\n        this.opcodes = {};\n    }\n\n    update (id, arg, selfTime, totalTime, count) {\n        if (id === this.blockFunctionId) {\n            if (!this.opcodes[arg]) {\n                this.opcodes[arg] = new StatView(arg);\n            }\n            this.opcodes[arg].update(selfTime, totalTime, count);\n        }\n    }\n}\n\nclass OpcodeTable extends StatTable {\n    constructor (options) {\n        super(options);\n\n        this.profiler = options.profiler;\n        this.opcodes = options.opcodes;\n        this.frames = options.frames;\n    }\n\n    keys () {\n        const keys = Object.keys(this.opcodes.opcodes);\n        keys.sort();\n        return keys;\n    }\n\n    viewOf (key) {\n        return this.opcodes.opcodes[key];\n    }\n\n    isSlow (key) {\n        const blockFunctionTotalTime = this.frames.frames[this.profiler.idByName('blockFunction')].totalTime;\n        const rowTotalTime = this.opcodes.opcodes[key].totalTime;\n        const percentOfRun = rowTotalTime / blockFunctionTotalTime;\n        return percentOfRun > SLOW;\n    }\n}\n\nclass ProfilerRun {\n    constructor ({vm, maxRecordedTime, warmUpTime}) {\n        this.vm = vm;\n        this.maxRecordedTime = maxRecordedTime;\n        this.warmUpTime = warmUpTime;\n\n        vm.runtime.enableProfiling();\n        const profiler = this.profiler = vm.runtime.profiler;\n        vm.runtime.profiler = null;\n\n        const runningStats = this.runningStats = new RunningStats(profiler);\n        const runningStatsView = this.runningStatsView = new RunningStatsView({\n            dom: document.getElementsByClassName('profile-count-group')[0],\n\n            runningStats,\n            maxRecordedTime\n        });\n\n        const frames = this.frames = new Frames(profiler);\n        this.frameTable = new FramesTable({\n            table: document\n                .getElementsByClassName('profile-count-frame-table')[0]\n                .getElementsByTagName('tbody')[0],\n\n            profiler,\n            frames\n        });\n\n        const opcodes = this.opcodes = new Opcodes(profiler);\n        this.opcodeTable = new OpcodeTable({\n            table: document\n                .getElementsByClassName('profile-count-opcode-table')[0]\n                .getElementsByTagName('tbody')[0],\n\n            profiler,\n            opcodes,\n            frames\n        });\n\n        const stepId = profiler.idByName('Runtime._step');\n        profiler.onFrame = ({id, arg, selfTime, totalTime, count}) => {\n            if (id === stepId) {\n                runningStatsView.render();\n            }\n\n            runningStats.update(id, arg, selfTime, totalTime, count);\n            opcodes.update(id, arg, selfTime, totalTime, count);\n            frames.update(id, arg, selfTime, totalTime, count);\n        };\n    }\n\n    run () {\n        this.projectId = loadProject();\n\n        window.parent.postMessage({\n            type: 'BENCH_MESSAGE_LOADING'\n        }, '*');\n\n        this.vm.on('workspaceUpdate', () => {\n            setTimeout(() => {\n                window.parent.postMessage({\n                    type: 'BENCH_MESSAGE_WARMING_UP'\n                }, '*');\n                this.vm.greenFlag();\n            }, 100);\n            setTimeout(() => {\n                window.parent.postMessage({\n                    type: 'BENCH_MESSAGE_ACTIVE'\n                }, '*');\n                this.vm.runtime.profiler = this.profiler;\n            }, 100 + this.warmUpTime);\n            setTimeout(() => {\n                this.vm.stopAll();\n                clearTimeout(this.vm.runtime._steppingInterval);\n                this.vm.runtime.profiler = null;\n\n                this.frameTable.render();\n                this.opcodeTable.render();\n\n                window.parent.postMessage({\n                    type: 'BENCH_MESSAGE_COMPLETE',\n                    frames: this.frames.frames,\n                    opcodes: this.opcodes.opcodes\n                }, '*');\n\n                setShareLink({\n                    fixture: {\n                        projectId: this.projectId,\n                        warmUpTime: this.warmUpTime,\n                        recordingTime: this.maxRecordedTime\n                    },\n                    frames: this.frames.frames,\n                    opcodes: this.opcodes.opcodes\n                });\n            }, 100 + this.warmUpTime + this.maxRecordedTime);\n        });\n    }\n\n    render (json) {\n        const {fixture} = json;\n        document.querySelector('[type=text]').value = [\n            fixture.projectId,\n            fixture.warmUpTime,\n            fixture.recordingTime\n        ].join(',');\n\n        this.frames.frames = json.frames.map(\n            frame => Object.assign(new StatView(), frame, {\n                name: this.profiler.nameById(this.profiler.idByName(frame.name))\n            })\n        );\n\n        this.opcodes.opcodes = {};\n        Object.entries(json.opcodes).forEach(([opcode, data]) => {\n            this.opcodes.opcodes[opcode] = Object.assign(new StatView(), data);\n        });\n\n        this.frameTable.render();\n        this.opcodeTable.render();\n    }\n}\n\n/**\n * Run the benchmark with given parameters in the location's hash field or\n * using defaults.\n */\nconst runBenchmark = function () {\n    // Lots of global variables to make debugging easier\n    // Instantiate the VM.\n    const vm = new VirtualMachine();\n    Scratch.vm = vm;\n\n    vm.setTurboMode(true);\n\n    const storage = new ScratchStorage();\n    const AssetType = storage.AssetType;\n    storage.addWebSource([AssetType.Project], getProjectUrl);\n    storage.addWebSource([AssetType.ImageVector, AssetType.ImageBitmap, AssetType.Sound], getAssetUrl);\n    vm.attachStorage(storage);\n\n    new LoadingProgress(progress => {\n        const setElement = (name, value) => {\n            document.getElementsByClassName(name)[0].innerText = value;\n        };\n        const sinceLoadStart = key => (\n            `(${(window[key] || Date.now()) - window.ScratchVMLoadStart}ms)`\n        );\n\n        setElement('loading-total', 1);\n        setElement('loading-complete', progress.dataLoaded);\n        setElement('loading-time', sinceLoadStart('ScratchVMLoadDataEnd'));\n\n        setElement('loading-content-total', progress.contentTotal);\n        setElement('loading-content-complete', progress.contentComplete);\n        setElement('loading-content-time', sinceLoadStart('ScratchVMDownloadEnd'));\n\n        setElement('loading-hydrate-total', progress.hydrateTotal);\n        setElement('loading-hydrate-complete', progress.hydrateComplete);\n        setElement('loading-hydrate-time', sinceLoadStart('ScratchVMLoadEnd'));\n\n        if (progress.memoryPeak) {\n            setElement('loading-memory-current',\n                `${(progress.memoryCurrent / 1000000).toFixed(0)}MB`\n            );\n            setElement('loading-memory-peak',\n                `${(progress.memoryPeak / 1000000).toFixed(0)}MB`\n            );\n        }\n    }).on(storage, vm);\n\n    let warmUpTime = 4000;\n    let maxRecordedTime = 6000;\n\n    if (location.hash) {\n        const split = location.hash.substring(1).split(',');\n        if (split[1] && split[1].length > 0) {\n            warmUpTime = Number(split[1]);\n        }\n        maxRecordedTime = Number(split[2] || '0') || 6000;\n    }\n\n    new ProfilerRun({\n        vm,\n        warmUpTime,\n        maxRecordedTime\n    }).run();\n\n    // Instantiate the renderer and connect it to the VM.\n    const canvas = document.getElementById('scratch-stage');\n    const renderer = new ScratchRender(canvas);\n    Scratch.renderer = renderer;\n    vm.attachRenderer(renderer);\n    const audioEngine = new AudioEngine();\n    vm.attachAudioEngine(audioEngine);\n    vm.attachV2BitmapAdapter(new ScratchSVGRenderer.BitmapAdapter());\n\n    // Feed mouse events as VM I/O events.\n    document.addEventListener('mousemove', e => {\n        const rect = canvas.getBoundingClientRect();\n        const coordinates = {\n            x: e.clientX - rect.left,\n            y: e.clientY - rect.top,\n            canvasWidth: rect.width,\n            canvasHeight: rect.height\n        };\n        Scratch.vm.postIOData('mouse', coordinates);\n    });\n    canvas.addEventListener('mousedown', e => {\n        const rect = canvas.getBoundingClientRect();\n        const data = {\n            isDown: true,\n            x: e.clientX - rect.left,\n            y: e.clientY - rect.top,\n            canvasWidth: rect.width,\n            canvasHeight: rect.height\n        };\n        Scratch.vm.postIOData('mouse', data);\n        e.preventDefault();\n    });\n    canvas.addEventListener('mouseup', e => {\n        const rect = canvas.getBoundingClientRect();\n        const data = {\n            isDown: false,\n            x: e.clientX - rect.left,\n            y: e.clientY - rect.top,\n            canvasWidth: rect.width,\n            canvasHeight: rect.height\n        };\n        Scratch.vm.postIOData('mouse', data);\n        e.preventDefault();\n    });\n\n    // Feed keyboard events as VM I/O events.\n    document.addEventListener('keydown', e => {\n        // Don't capture keys intended for Blockly inputs.\n        if (e.target !== document && e.target !== document.body) {\n            return;\n        }\n        Scratch.vm.postIOData('keyboard', {\n            keyCode: e.keyCode,\n            isDown: true\n        });\n        e.preventDefault();\n    });\n    document.addEventListener('keyup', e => {\n        // Always capture up events,\n        // even those that have switched to other targets.\n        Scratch.vm.postIOData('keyboard', {\n            keyCode: e.keyCode,\n            isDown: false\n        });\n        // E.g., prevent scroll.\n        if (e.target !== document && e.target !== document.body) {\n            e.preventDefault();\n        }\n    });\n\n    // Run threads\n    vm.start();\n};\n\n/**\n * Render previously run benchmark data.\n * @param {object} json data from a previous benchmark run.\n */\nconst renderBenchmarkData = function (json) {\n    const vm = new VirtualMachine();\n    new ProfilerRun({vm}).render(json);\n    setShareLink(json);\n};\n\nconst onload = function () {\n    if (location.hash.substring(1).startsWith('view')) {\n        document.body.className = 'render';\n        const data = location.hash.substring(6);\n        const frozen = atob(data);\n        const json = JSON.parse(frozen);\n        renderBenchmarkData(json);\n    } else {\n        runBenchmark();\n    }\n};\n\nwindow.onhashchange = function () {\n    location.reload();\n};\n\nif (window.performance) {\n    performance.mark('Scratch.EvalEnd');\n    performance.measure('Scratch.Eval', 'Scratch.EvalStart', 'Scratch.EvalEnd');\n}\n\nwindow.ScratchVMEvalEnd = Date.now();\n\nonload();\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","__webpack_require__.amdO = {};","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"benchmark\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkscratch_vm\"] = self[\"webpackChunkscratch_vm\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendors-node_modules_vernier_godirect_dist_godirect_min_cjs_js-node_modules_atob_browser-atob-7f0f5d\",\"vendors-node_modules_scratch-audio_src_index-exposed_js-node_modules_scratch-render_src_index-35ce81\",\"src_extensions_scratch3_video_sensing_library_js\",\"src_index-exposed_js\"], () => (__webpack_require__(\"./src/playground/benchmark.js\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}